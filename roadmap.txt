Roadmap for a Carbon-Style DateTime Library in
Dart
Introduction:
Building a Carbon-style date/time library in Dart means replicating the powerful and fluent API of PHP’s
Carbon (from Laravel) for Dart/Flutter developers. The goal is to support creation, parsing, formatting,
manipulation, comparison, intervals, time zones, localization, rounding, macro extensions,
serialization, and mutability control – essentially the full feature set Carbon offers. This library should
work seamlessly on both Flutter (mobile/web) and pure Dart (server) environments, providing a chainable
API (e.g. Carbon.now().addDays(3).startOfMonth() ) that is intuitive and readable 1 . We will
leverage existing Dart packages (like

time_machine ,

intl ,

timeago , and

clock ) to avoid

reinventing the wheel and ensure robust implementations. The following roadmap outlines a modular
architecture, key design decisions, integration strategy for third-party packages, development milestones,
and considerations for pluggability and testing.

Modular Architecture Overview
Core API and Interface:
Define a core Carbon interface (e.g. CarbonInterface ) that declares all expected date/time operations
(creation, addition/subtraction, formatting, comparison, etc.). This will act as the primary API that users
interact with, ensuring a consistent fluent interface across different implementations. For example,
CarbonInterface
might include methods like
addDays(int
days) ,
startOfMonth() ,
format(String

pattern) ,

isBefore(CarbonInterface

other) ,

toJson() , etc. All Carbon

objects, regardless of backend, will implement this interface.
Implementation Layers:
- Core Implementation: Provide a default implementation (e.g. class Carbon ) that wraps Dart’s built-in
DateTime

for basic functionality. This class will implement

foundation. By default, it uses

DateTime

CarbonInterface

and serve as the

internally for timestamps, which ensures portability and

simplicity.
- Adapter/Backend Layer: Design the library to be pluggable via an adapter or strategy pattern. This
means we can have multiple underlying date/time engines that conform to CarbonInterface . For
instance:
- Dart DateTime Backend: Uses DateTime and Duration for computations (default).
- Time Machine Backend: Uses the

time_machine

package types ( Instant ,

ZonedDateTime , etc.) to gain rich timezone and calendar support

2

LocalDateTime ,

.

- Jiffy or Other Backend: Potentially wrap the Jiffy library for its parsing and human-friendly API.
Each

backend

can

be

implemented

TimeMachineAdapter ) that implements

as

an

adapter

CarbonInterface

class

(e.g.

DartDateTimeAdapter ,

by delegating calls to the underlying

library’s functions. This adheres to the Strategy pattern, allowing the library to select an appropriate date
engine at runtime or via configuration 3 . The core Carbon class might internally hold a reference to a

1

DateTimeBackend strategy that it uses for all operations. - Fluent API Design: All implementation classes
will be designed for method chaining. Methods like

addDays() or setTimezone() will return a

Carbon instance (either the same instance or a new one, depending on mutability settings). This mirrors
Carbon’s fluent style where multiple transformations can be chained in one expression 1 . - Trait-like
Mixins: Organize related behaviors into mixins or extension classes to mirror Carbon’s trait groupings. For
example, implement a mixin CarbonComparison for comparison methods ( isBefore , isSameDay ,
etc.), a mixin

CarbonAdjustment

for manipulation methods ( addDays ,

subtractMonths ,

startOf… , endOf… ), and a mixin CarbonFormatting for output and formatting methods. These
mixins can be applied to the core classes (both mutable and immutable versions) to compose the full
feature set. This improves code organization and reuse. It also allows potential opt-in of features if needed
(though in this project we intend to include the full feature set by default).
Pluggability via Adapters:
To support multiple date/time backends, the design will use an abstract factory or initializer to create
Carbon instances with a specific backend. For example, a static initializer Carbon.useTimeMachine()
could produce Carbon objects backed by the Time Machine engine. Under the hood, this might instantiate a
Carbon class with a TimeMachineAdapter injected. Alternatively, the library could expose separate
classes like CarbonTM (for Time Machine) or provide a configuration at a global level to switch the
backend strategy. The key is that the higher-level API remains the same, while the underlying computations
are handled by the chosen adapter. This approach ensures the library is extensible (new adapters can be
added for other packages or future Dart date APIs) and maintainable, isolating third-party specifics in
adapter classes.
Diagram – Architecture Sketch (pseudo-code):

abstract class CarbonInterface {
// Core API methods
CarbonInterface now();
CarbonInterface parse(String input, {String? format, String? locale});
CarbonInterface add(Duration duration);
CarbonInterface addDays(int days);
CarbonInterface startOf(String unit);
bool isBefore(CarbonInterface other);
// ... other methods for diff, formatting, etc.
}
class Carbon implements CarbonInterface {
// Holds a reference to underlying DateTime or strategy
late DateTime _dt;
// Implementation of interface using Dart DateTime by default
// e.g.:
CarbonInterface addDays(int days) {
_dt = _dt.add(Duration(days: days)); // mutate internal DateTime
return this;
}
CarbonInterface startOf(String unit) {

2

if(unit == 'month') {
_dt = DateTime(_dt.year, _dt.month, 1); // set to first day
}
return this;
}
// ... other methods
}
// Adapter example for Time Machine backend:
class TimeMachineAdapter implements CarbonInterface {
late LocalDateTime _ldt;
// implement same methods using Time Machine types
CarbonInterface addDays(int days) {
_ldt = _ldt.addDays(days);
return this;
}
CarbonInterface startOf(String unit) {
if(unit == 'month') {
_ldt = LocalDateTime(_ldt.year, _ldt.month, 1, 0, 0, 0);
}
return this;
}
// ... etc.
}
In practice, the actual architecture will be more refined (with factories or a Carbon class that can delegate to a
chosen strategy internally), but the above sketch illustrates having multiple implementations conforming to one
interface.
By modularizing the architecture (core interface, multiple adapters, and feature mixins), we achieve a
flexible design where new features or backends can be integrated without affecting others. This modular
approach also aids testing (each component can be tested in isolation) and clarity.

Feature Set Implementation Plan
Each major Carbon feature will be implemented with Dart-friendly approaches, often by leveraging existing
packages:

1. Creation & Parsing
Task: Implement convenient ways to create date/time instances. This includes “now”, specific date
constructors, and parsing from strings.
- Now/Today: Provide static constructors like Carbon.now() (current date-time) and Carbon.today()
(with time set to 00:00). These will use the injected clock (from the clock package) to get current time,
rather than calling DateTime.now() directly, to allow testability
internally does clock.now() so tests can inject a fake time source.

3

4

. For example: Carbon.now()

- Specific Date/Time: Methods like Carbon.create(year, month, day, ...) to create a specific
date-time easily (wrapping DateTime(...) or LocalDateTime.create(...) depending on backend).
-

Parsing
from
String:
Provide
a
flexible
Carbon.parse(String input, {String? format, String? locale}) . If a format is provided (e.g.

"YYYY-MM-DD" or "dd MMM, yyyy"), use the intl package’s DateFormat to parse the string

5

. If no

format is given, attempt common formats (ISO 8601, RFC2822, etc.) by falling back to DateTime.parse or
Time Machine’s parsing utilities.
- Integration: Use intl for parsing known patterns. For more complex parsing (or different calendars), the
Time Machine adapter can use ZonedDateTimePattern or similar from time_machine for parsing in
specific cultures 6 .
- Flexibility: The parse method can accept timestamps (integers) or other date objects as well, similar to
Carbon’s
Carbon::parse()
which
can
take
various
inputs 7 .
For
example,
Carbon.parse(1609459200) could interpret as a UNIX timestamp (seconds).
- Milestone: Basic parsing of ISO strings and a few common formats will be implemented early, and
extended as needed. Ensure that locale-specific parse (month names in different language) is possible via
intl or time_machine culture data.

2. Formatting & Localization
Task: Implement rich formatting of dates to strings, including locale-specific output.
- Format Patterns: Use Dart’s intl package ( DateFormat ) to format dates. Provide a method
format(String pattern) that accepts pattern strings similar to Carbon/Moment.js (we can support
both ICU patterns and common aliases). For example, carbon.format('YYYY-MM-DD') should output
"2025-11-14" etc. We might map "YYYY" -> "yyyy" for DateFormat since Carbon’s pattern tokens differ
slightly (this can be handled by a simple pattern translator or just document to use ICU patterns) 5 .
- Common Formats Shortcuts: Like Carbon, include convenience getters or methods for common formats
(e.g. toIso8601String() , toRFC2822String() , or even properties like carbon.dateString for
"YYYY-MM-DD"). This increases ease of use.
- Localization: Allow specifying a locale for formatting. The CarbonInterface can have a method or
property for locale (similar to Carbon’s $date->locale('fr') ). Using intl , we can set the locale on
the

DateFormat

to

output

month/day

names

in

that

language

8

.

e.g.,

carbon.locale('es').format('LLLL') could produce a Spanish formatted date. For relative time
strings (discussed below), support localization as well.
- Example: Carbon.now().locale('fr').format('EEEE, MMMM d, yyyy') might output "vendredi,
novembre 14, 2025" (French) if locale data is available. Under the hood, intl handles locale-specific
names. The library should bundle or prompt developers to include the relevant intl locale data for
Flutter.
- Time Machine Integration: If using the Time Machine backend, we can alternatively use its formatting
patterns via Culture . Time Machine has its own pattern strings (similar to Noda Time) and culture-aware
formatting

6

. The adapter for Time Machine would delegate

format()

to Time Machine’s

toString(pattern, culture) .
- Edge Cases: Ensure time zones are reflected in formatting if needed (e.g., ability to output timezone
abbreviation or offset). If using DateFormat , the pattern "z" or "Z" can include offsets (with intl , "Z"
gives offset like +0800). Time Machine can output zone abbreviation given a ZonedDateTime .

4

3. Date Manipulation & Rounding
Task: Support adding, subtracting, and rounding/truncating dates by various units, following Carbon’s
fluent style.
- Add/Subtract Durations: Implement methods like addDays(int n) , subDays(int n) (and similarly
for weeks, months, years, hours, minutes, etc.). These methods will modify the date/time by the given
amount. For underlying DateTime , we use add(Duration) for fixed spans (days, hours, minutes) and
custom logic for months/years (since adding months isn’t a built-in operation). For example,
addMonths(n) can add n months while adjusting the day if necessary (taking care of month length
overflows). If using Time Machine, it provides methods like LocalDateTime.addDays() or Period
addition which can handle month arithmetic more gracefully.
- StartOf/EndOf Units: Provide methods to round or truncate the datetime to a unit boundary, similar to
Carbon’s startOfDay() , endOfMonth() , etc. For example, startOfDay() would set the time to
00:00:00 (keeping the same date), startOfMonth() sets date to the 1st and time to start of that day, and
endOfMonth() could set date to last day 23:59:59. These help in rounding down or up to a unit.
Implementation for startOf(unit) involves zeroing out smaller units than the one specified. Rounding
to nearest quarter-hour or custom interval could also be included (e.g. round(TimeUnit.minutes, 15)
to round to nearest 15 minutes).
- Mutability Consideration: If the Carbon object is mutable (default), addDays and others will alter the
internal state and return this (so that the chain continues on the same object). If immutable, these
methods will create a new Carbon instance with the adjusted time. We will implement this logic such that
it’s transparent to the user which mode is in use (detailed under Mutability Control below).
- Examples:

// Mutable usage (in-place modification)
var date = Carbon.today();
date.addDays(3).startOfMonth(); // date is now the start of next month's day 3
if crossing month
// Immutable usage (each returns new instance)
var date2 = CarbonImmutable.today();
var date3 = date2.addDays(3);
// date2 unchanged, date3 is new object
var beginning = date3.startOf('month'); // new object at start of month
- Relative Durations (CarbonInterval): Implement a way to represent time spans or differences in
components (days, months, etc.). This could be a separate class (like CarbonInterval ) to hold a span
(similar to Duration but with calendar units). However, since Dart’s core Duration covers generic time
spans in microseconds (no months/years), we might integrate with Time Machine’s Period or create our
own simple interval for Carbon. For the initial scope, focusing on using Duration for basic differences is
sufficient (with the caveat that months and years differences are context-dependent). Advanced use (like
CarbonPeriod sequences) could be a future extension.
- Milestone: By the first iteration, ensure all basic unit add/subtract and startOf/endOf for day, week,
month, year are working. Rounding to arbitrary intervals can be added once core is stable.

5

4. Comparison & Intervals
Task: Provide methods to compare dates and compute differences.
- Comparisons: Implement isBefore , isAfter , isSame (with optional unit precision, e.g. same day,
same hour), and

isBetween

comparison utilities

9

(to check if a date falls between two others). These mirror Carbon’s

. Under the hood, for isBefore/After we compare the underlying timestamps.

For isSameDay or similar, compare formatted date parts or use DateTime’s properties.
- Equality: Overload the equality operator ( == ) and compareTo (for Comparable ) to allow sorting
Carbon instances easily. Two Carbon instances are equal if their moment in time is equal (and perhaps if
their types and timezones are also considered, depending on design). We should override hashCode as well
if we override equality.
- Difference Calculation: Provide methods like diffInDays(other) or a general difference(other)
that returns a Duration or an Interval. For simple uses, returning a Duration (the difference in time) is
straightforward. Additionally, higher-level diffs: e.g.

diffInYears(other)

that counts whole year

boundaries crossed between the two dates, etc., similar to Carbon’s diffInX methods. Time Machine’s
Period.difference() or Jiffy’s diff can be used if available.
- Human-Friendly Differences: The classic Carbon feature diffForHumans() should be supported –
producing strings like "5 days ago" or "2 hours from now" 10 11 . Instead of writing this logic from scratch,
we integrate the timeago package. The timeago library provides fuzzy time difference strings and
supports multiple locales 12 . We can wrap timeago.format(dateTime, locale: xx) inside our
diffForHumans()

implementation. For example,

Carbon.yesterday().diffForHumans()

might

use timeago to return "1 day ago" automatically 12 . We will ensure that timeago is configured for the
desired locale (perhaps automatically use the Carbon instance’s locale setting if set).
- Intervals and Ranges: (Optional) Provide a way to iterate over date ranges (like CarbonPeriod in PHP). For
instance, a method to generate every day between two dates, etc. This could be a separate component
(maybe a CarbonPeriod class with start, end, and step). We might plan this for later phases, focusing
first on core date operations.
- Milestone: Comparators and diffForHumans should be implemented early, as they are user-facing. The
use of timeago for diffForHumans is a quick win to cover multiple languages and formats 12 . Ensure
we have test cases for boundary conditions (e.g. just now, singular vs plural, future vs past differences).

5. Time Zone Handling
Task: Incorporate robust timezone support, beyond Dart’s basic UTC/local handling.
- Basic TZ handling: Dart’s DateTime has an offset and a concept of local vs UTC. We will provide
methods to get or set the timezone of a Carbon instance. For basic usage (without time_machine ),
support .toUtc() and .toLocal() conversions (wrapping DateTime.toUtc() etc.). Also store a flag
or property for the timezone. However, Dart cannot represent arbitrary zones (like "America/New_York") out
of the box – it only knows the system local and UTC.
- Advanced TZ (using Time Machine): To fully support arbitrary time zones (and historical offsets, daylight
savings, etc.), integrate the time_machine package 13 . When this integration is active, we can:
- Allow creating a Carbon in a specific timezone by name (e.g. Carbon.now('Europe/Paris') ). Time
Machine’s DateTimeZoneProviders.tzdb gives access to the IANA database of zones 14 . We would
initialize Time Machine (which loads TZ data) at library startup or on first use.
- Represent the datetime internally as a ZonedDateTime (for the TimeMachine adapter), which keeps
track of zone and instant. Provide methods like carbon.inTimeZone('Asia/Tokyo') to convert and
return a new Carbon instance in that zone.

6

- Ensure that when formatting, the zone offset or abbreviation can be included (Time Machine can format
z or Z patterns with zone info 6 ).
- UTC Best Practices: Encourage using UTC internally and converting to locale when needed (this is a
Carbon best practice as well) 15 . Our library internally might do calculations in UTC for consistency
(especially if mixing with Time Machine, which has Instant for timeline moment).
- Daylight Savings & Transitions: When adding durations that cross DST boundaries, consider how to
handle ambiguities. For example, adding 24 hours vs adding 1 day may differ if a DST change occurs. Time
Machine handles these via ZonedDateTime transitions. In our API, we could offer both behaviors:
absolute duration vs calendar day addition. For instance, adding a Period of 1 day using Time Machine will
roll over DST properly (preserving local time or not depending on context). Document any such behavior for
users.
- Fallback without TimeMachine: If a user doesn’t want the heavy dependency of Time Machine, our
library should still function with basic timezone support (only UTC or system local). Perhaps mark the
advanced zone features as only available when Time Machine is enabled. We can make time_machine an
optional dependency and use conditional imports or a separate package feature for it. However, for a fully
featured library, bundling it is reasonable.
- Milestone: Incorporate time_machine by mid-development. Key tasks: initialization of Time Machine
(one-time TimeMachine.initialize() call), providing an API to set timezone on a Carbon instance, and
ensuring format/parse use the correct zone context. Write tests for converting between zones and for a few
known DST transition dates.

6. Localization & Internationalization
Task: Support multiple languages for both formatting and humanized output.
- Formatting Locale: As mentioned, the format function should respect locale. We will use intl for
this; developers can set the desired locale by either calling a method (e.g. carbon.locale('fr_CA') ) or
by passing locale to format (like carbon.format(pattern, locale: 'fr_CA') ). The Carbon instance
can store a locale code internally (default to system locale or 'en_US' ) to use in all operations unless
overridden. This parallels Carbon’s $date->locale('xx') usage 16 .
- Relative Time Locale: The timeago package supports many locales for "time ago" strings. We will
ensure to initialize or use

timeago.setLocaleMessages(locale, messages)

for the locales we

support, or use the pre-defined ones from the package. When diffForHumans() is called, it should
generate output in the instance’s locale (if available, otherwise default to English). For example, if locale is
French, Carbon.now().subHours(5).diffForHumans() should return "il y a 5 heures" (French for "5
hours ago"), provided by timeago’s French messages.
- Other Locale-Specific Features: Carbon has features like first day of week depending on locale, etc. We
should consider if any such locale-specific rules are needed (for example, in some locales week starts on
Monday vs Sunday). Time Machine’s Culture can provide information like first day of week if needed. We
might incorporate this into our library (e.g., an isWeekend() method that could use locale info or default
to Saturday/Sunday).
- Pluralization and Units: Ensure our formatting of durations (for any custom messages or our own
methods) handles pluralization correctly based on locale rules. The intl package provides some
pluralization capabilities if we implement messages, but since we rely on timeago for human diffs, that is
largely handled.
- Milestone: By the time we finalize formatting and diffForHumans, the localization aspect should be
integrated. We will test formatting in a couple of locales and the diff strings in those locales as well.

7

7. Macro Extensions (Extensibility)
Task: Design a mechanism to allow users to extend the library with custom methods (mirroring Carbon’s
macros 17 ). In PHP Carbon, macros allow users to dynamically add new methods (both instance and static)
at runtime 7 . Dart does not allow true runtime method injection due to its static typing, but we can
provide alternative approaches:
- Static Extension Methods: Dart’s extension methods (added in Dart 2.7) enable adding new functionality
to classes in a static way. We can encourage an “extension library” approach: users can write an extension
on CarbonInterface or on Carbon to add their own utility methods. For example:

extension FiscalYearExtensions on CarbonInterface {
bool get isFiscalYearEnd {
return month == 12 && day == 31; // assuming Dec 31 as fiscal year end
}
}
This way, developers can add domain-specific functions. However, these are resolved at compile time and
cannot be added at runtime dynamically. It’s a trade-off but leverages Dart language features.
- Macro Registry: For truly dynamic behavior, we can implement a macro registry in the library: essentially
a Map<String, Function> of method names to implementations. Then, provide a method like
Carbon.registerMacro(String name, Carbon Function(dynamic args) fn) to register a macro.
The Carbon class can override noSuchMethod (which is invoked when a method or property isn’t found)
to intercept calls to undefined methods. In noSuchMethod , we can look up the method name in the
macro registry and execute it if found. This is similar to how Laravel’s Macroable trait works, catching calls
and routing them to the stored closures 17 18 . For instance,
Carbon.registerMacro('nextFiscalQuarter', (Carbon self) => ...) could be defined and
later carbon.nextFiscalQuarter() would trigger noSuchMethod , find the macro, and execute it.
- Limitation: Calls to such macros might require using the Carbon instance in dynamic context to avoid
static type errors. E.g., (carbon as dynamic).nextFiscalQuarter() . This is not as clean as in PHP.
We will document this requirement if using noSuchMethod . Alternatively, we could provide an explicit call
like carbon.callMacro('nextFiscalQuarter', args) or static
Carbon.invoke('nextFiscalQuarter', carbon, args) .
- Despite these hurdles, offering a macro system aligns with Carbon’s extensibility goals 3 and can be very
powerful if implemented carefully. We will include unit tests for macro registration and invocation to ensure
it works as expected.
- Mixins for Groups: Another form of extension is allowing users to mix in sets of methods (Carbon in PHP
allows mixin classes of macros 19 ). In Dart, we might simulate this by encouraging users to contribute
extension methods grouped in their own library, or by our library providing some optional mixin classes
that can be applied. For example, if someone wants all Carbon objects to have business-day calculations, we
could provide a mixin BusinessDayMixin that adds methods like nextBusinessDay() . The user could
then do class MyCarbon extends Carbon with BusinessDayMixin {} to get those (but using
inheritance might complicate our fluent returns, so extensions are likely simpler).
- Milestone: Implement a basic macro system after core features are done. Test the registration and calling
of a macro. Also, provide at least one example macro in documentation (like adding a custom
endOfFiscalYear method via macro). Clearly note any differences from PHP Carbon macros due to

8

language constraints (for example, no auto-completion for dynamic macros, similar to Carbon’s note that
IDEs don’t see dynamic methods 20 ).

8. Mutability Control (Mutable vs Immutable)
Task: Provide both mutable and immutable date-time objects, giving developers control over in-place
modification versus functional style. Carbon for PHP introduced CarbonImmutable to avoid unintended
modifications 21 . We plan a similar approach:
- Carbon (Mutable): The primary Carbon class instance acts mutable – meaning methods like addDays
will modify the internal state and return this . This is convenient for chaining but means if two variables
point to the same Carbon instance, updating one affects the other (like how DateTime in Dart is immutable,
but here we simulate mutability by changing our wrapper’s internal _dt ).
- CarbonImmutable: We will create a separate class (perhaps CarbonImmutable ) that implements the
same CarbonInterface but overrides all mutating methods to return new instances instead of modifying
itself. For example, CarbonImmutable.addDays(1) will internally compute the new date but return a
fresh

CarbonImmutable

object with that value, leaving the original unchanged. This mirrors

CarbonImmutable’s behavior in PHP 21 . We can achieve this by having

CarbonImmutable

extend

Carbon but override mutating methods, or by having a common base that checks a flag. A simple strategy
is to use two classes and share code via mixins: one mixin for all methods that either mutate or clone
depending on a isImmutable property. In practice, separate classes might be clearer.
- Interconversion: Provide convenience methods to switch modes, e.g. carbon.toImmutable() and
carbonImmutable.toMutable() , akin to Carbon’s methods 22 . This gives flexibility in APIs – one could
use mutable objects during calculations and then convert to immutable before returning from an API to
avoid accidental changes.
- Default Choice: Likely, we will choose the mutable version as the default Carbon (to match typical
Carbon usage). But we’ll encourage use of CarbonImmutable when immutability is desired for safer code.
This dual-class approach ensures no performance overhead for checking immutability flag on each
operation; the decision is made by which class you use.
- Example Difference:

Carbon date = Carbon.parse('2025-01-01');
date.addDays(1);
print(date); // 2025-01-02 (modified in place)
CarbonImmutable date2 = CarbonImmutable.parse('2025-01-01');
var date3 = date2.addDays(1);
print(date2); // 2025-01-01 (original remains)
print(date3); // 2025-01-02 (new instance)
- Milestone: Introduce CarbonImmutable class after implementing core methods in Carbon . Test that
each method returns a new instance and that the original remains unchanged. Also test isMutable /
isImmutable properties if provided (we can include boolean getters to check). This will likely be
implemented in a later phase of development, once the base functionality is solid.

9

9. Serialization
Task: Enable converting Carbon instances to and from JSON or other serializable formats easily.
- To JSON/String: Implement
toString()
to return ISO 8601 format by default

(e.g.

"2025-11-14T08:33:27.000Z" ). Also implement toJson() (possibly the same output as toString
or a timestamp) so that when Carbon is used with jsonEncode , it produces a useful representation. In
Carbon PHP, jsonSerialize() returns a standardized string (ISO8601) by default 23 , and we will follow
that idea. For example, jsonEncode(Carbon.now()) would yield "2025-11-14T08:33:27.000Z"
(assuming

UTC).

We

might

Carbon::serializeUsing()

allow
24

customization

of

this

via

a

setting

similar

to

Carbon’s

25 , but initially a sensible default is enough.

- From JSON: If our library might be used with JSON decoding, we can provide a factory like
Carbon.fromJson(String) which parses an ISO8601 string or timestamp number. This is essentially
similar to Carbon.parse logic. We should support at least ISO strings and perhaps int timestamps (ms or
seconds since epoch). For integration with JSON serialization libraries (like

json_serializable ),

documenting how to annotate a Carbon field (e.g., using a custom DateTimeConverter or writing our
own CarbonConverter ) would be useful for users.
- Other Serializations: If needed, provide toEpochMilliseconds() or similar for numeric timestamps,
and Carbon.fromMilliseconds(ms) for constructing from epoch. Also possibly toIso8601String()
explicitly if users want that format.
- Milestone: Very early on, ensure

toString()

and basic JSON encoding works, as these are

straightforward (we can directly use DateTime.toIso8601String() on the underlying and return it).
Customizing JSON output can be an advanced feature added towards the end if time permits.

Third-Party Dependency Integration Strategy
To achieve the above features without excessive low-level coding, we integrate the following packages
strategically:
• intl (Internationalization): Use for parsing and formatting dates/times in various locales and
patterns. The DateFormat class in intl covers a wide range of formatting needs and supports
different locales (as long as the locale data is imported)

5

. We’ll use intl for all standard format

operations and parsing of common formats, which significantly reduces implementation effort for
localization. We just need to be mindful of pattern differences (documenting them or mapping
Carbon-style patterns to ICU patterns).
• time_machine : This package provides comprehensive timezone and calendar support in Dart 13 .
Our strategy is to use time_machine for features that Dart’s core lacks:
• Time zone conversions and named zones (via DateTimeZone and ZonedDateTime )

2

.

• Alternative calendars or high precision times if needed (time_machine supports Gregorian by
default, but also others; primarily we use Gregorian).
• More granular control on date math (avoiding issues with Dart DateTime when adding months
etc., since time_machine’s Period handles those explicitly).
Integration plan: Include time_machine as a dependency and initialize it when the library is first
used (the user might need to call something like await Carbon.initTimeZones() to load tz
data asynchronously). Then our CarbonTimeMachine adapter will call into time_machine APIs. We'll
also use time_machine for any advanced parsing or formatting that intl doesn’t cover (e.g.,
parsing with a specific culture or formatting with non-Gregorian calendar if ever needed).

10

• timeago : Instead of hardcoding logic for "X time ago" strings, we use timeago for humanreadable relative time 12 . This package provides a simple function timeago.format(DateTime
past, locale: xx) to get strings like "5 minutes ago" or "2 hours from now" with localization.
We will likely feed it thisDate and (optionally) a reference date (another Carbon or now) for
computing the difference. Because timeago expects DateTime , our implementation will extract
the underlying DateTime or convert our internal type to DateTime (for Time Machine’s Instant,
convert to a DateTime via Instant.toDateTimeUtc() or similar). Using timeago means we
inherit support for many languages and pluralization rules out-of-the-box 12 .
• clock : To make our library testable and to allow controlling the flow of time (for things like
simulating now), we integrate the clock package. All calls to current time will go through
clock.now() instead of DateTime.now()

4

. We can have our static Carbon.now() use

clock.now() internally. In tests, one can do:
withClock(Clock.fixed(DateTime(2025,1,1)), () {
// inside here, Carbon.now() will use the fixed date
expect(Carbon.now().year, 2025);
});
This strategy (recommended by the Dart team 4 ) avoids us implementing a custom clock. It also
allows injection of fake time easily, which is crucial for testing time-dependent features like
diffForHumans outputs. The clock package is lightweight and has no effect on production
behavior except routing to system clock by default.
• Other Packages (if needed): We will review if Jiffy can be leveraged for some features. Jiffy itself
is a date library that wraps DateTime with moment.js style methods 26

27 . However, since we are

essentially building a more comprehensive solution, we may not need to depend on Jiffy. Instead, we
draw inspiration from Jiffy’s API and ensure our API covers similar ground (Jiffy offers parsing,
formatting, manipulation, and relative time as well). For example, Jiffy’s startOf(Unit.year)
usage 28 and fromNow() relative times are analogous to our goals. We might use Jiffy’s source as
a reference for some tricky parts (like how it handles locale or time units) but not include it as a
dependency to avoid redundancy.
Dependency Management:
We will declare these packages in pubspec.yaml . For critical packages like intl and clock , we make
them required. For time_machine and timeago , we can also make them required dependencies
because they significantly enhance functionality (though making time_machine optional is possible, our
goal is a "fully featured" library, so we assume its inclusion). The architecture, however, allows a form of optin: if the user never calls timezone-specific methods, the time_machine code might never be invoked
(though it will still increase app size). We will clearly document that time_machine initialization is needed
for timezone features so developers know when it’s necessary.
By leveraging these libraries, we reduce implementation overhead and tap into well-tested solutions 3 .
Each of these packages will be wrapped or abstracted by our library so that users mostly interact with our
unified API, maintaining a seamless experience.

11

Design Patterns and Pluggability
Our design employs several software design patterns to ensure flexibility, testability, and maintainability:
• Strategy Pattern: As discussed, the choice of underlying date engine (Dart DateTime vs Time
Machine, etc.) is handled via a strategy that implements a common interface. This allows swapping
out implementations without changing the API 3 . For example, a user could configure the library
to use high-precision Instant from Time Machine as the backend if needed, or revert to
DateTime for simplicity. New strategies (like if a new official time library appears) can be added by
implementing the interface.
• Adapter Pattern: We use adapters to wrap third-party types into our CarbonInterface . The
adapter translates our generic method calls to library-specific calls. For instance, our
TimeMachineAdapter.addDays() will call _ldt.addDays(n) on a LocalDateTime . This
decouples our core logic from the specifics of each library. The adapter also helps with facade-like
behavior, presenting a unified face to the user while internally managing complexity of different
libraries.
• Fluent Interface: The entire API is designed around method chaining (a fluent API). This is not a GoF
pattern per se, but it’s a design principle that greatly enhances usability 29 . We ensure each setter/
manipulator returns the appropriate object (respecting mutability settings) so that calls can be
chained naturally. Fluent APIs improve code readability and intuitiveness, which is a known benefit of
Carbon in PHP 30 .
• Mixin (Trait) Composition: By using Dart mixins to group related methods, we follow a principle
similar to trait composition. This pattern helps break down the huge surface area of a date library
into logical units. It also facilitates code reuse between Carbon and CarbonImmutable – both
can apply the same mixin methods but differ in how they implement them (mutable vs immutable
override). This approach promotes the Single Responsibility Principle, as each mixin can focus on
one aspect (e.g., formatting or arithmetic).
• Factory Pattern: We may introduce factory methods or a factory class to handle object creation,
especially if instantiating different classes depending on context (e.g., a CarbonFactory that can
produce either mutable or immutable instances, or that takes a class reference to produce, as
Carbon PHP does with its Factory 31 ). In Dart, simple factory constructors or static methods can
suffice. For example, Carbon.from(DateTime dt) might detect if dt is a TimeMachine type or
normal, and return the appropriate Carbon type. We might not need a full abstract factory, but
having controlled creation points helps manage the pluggability.
• Dependency Injection: While not using a DI framework, we inject dependencies like the current
time source (via clock ) and allow injecting different adapters. This inversion of control (e.g.,
passing a Clock or setting a global strategy for date engine) makes testing and future extension
easier. In tests, we can inject a mock adapter if needed or use Clock.fixed as mentioned.
• Testing Patterns: We will adopt TDD principles for critical components. Using the clock package
is central to making time-dependent code testable 4 . Additionally, we will create abstract test
suites that each adapter must pass. For instance, a set of tests for addDays , format ,
diffForHumans that we run against a Carbon instance using Dart backend and again against one
using Time Machine backend, ensuring both yield the same observable behavior. This polymorphic
testing ensures consistency across backends.
Pluggability Considerations:
The user of our library might want to plug in their own custom behavior or extend functionality. We’ve

12

addressed this with macros and extension methods. Another aspect is pluggable data sources like custom
timezone data or localization. We will allow, for example, customizing the source of timezone data (Time
Machine allows providing your own DateTimeZoneProvider if needed). Our design should not hardcode a single source; instead, perhaps allow the user to specify a provider for time zones (defaulting to the
built-in tzdb). Similarly, for localization messages (like for diffForHumans ), if they want to override
phrasing, they could either use timeago ’s API to set custom messages or we provide a hook if needed.
The use of design patterns above ensures that our library can grow and adapt. Extensibility is built-in (both
through macros and through adding new adapters). Maintaining consistency is also important – by
enforcing the CarbonInterface , all implementations, whether our own or user-provided, must adhere to
the contract, which guarantees a uniform API surface.

Project Tasks and Milestones
Below is a breakdown of the development steps and milestones for the project:
1. Project Setup and Core Scaffolding
2. Create the Dart package structure. Define CarbonInterface with all planned methods (initially as
stubs).
3. Implement the base Carbon class wrapping DateTime with minimal functionality: now, basic
constructor, toString, and a simple add (using Duration).
4. Set up a Git repository and CI for running tests on multiple platforms (ensure it works on VM, Flutter,
web).
5. Milestone: Basic Carbon.now() returns current date and Carbon.parse() parses an ISO string
successfully.
6. Basic Operations and Fluent API
7. Implement core date arithmetic: addDays , addHours , etc., and subtract counterparts using
Dart Duration .
8. Implement comparison methods: isBefore , isAfter , equality operator.
9. Implement simple formatting using DateTime.toString() or custom formats for a quick test
(we will integrate intl next for full formatting).
10. Write unit tests for these methods with fixed known dates.
11. Milestone: Can add/subtract dates and compare results correctly (e.g., adding 1 day to Jan 31 yields
Feb 1, etc., verify edge cases).
12. Integrate intl for Parsing/Formatting
13. Add intl to pubspec. Implement Carbon.format(pattern) using DateFormat . Also
implement Carbon.parse(String, format) using DateFormat.parse .
14. Support locale by either adding an optional locale parameter or a Carbon.locale() setter that
stores locale. Pass this locale to DateFormat.
15. Add common format shortcuts (like toIso8601String , toDateString etc.).

13

16. Milestone: Formatting in at least one non-default locale works (e.g., French month names appear
when locale is set), and test parsing with a custom pattern.
17. Relative Time and timeago Integration
18. Add timeago to pubspec. Implement diffForHumans([CarbonInterface other]) using
timeago . If other is given, compute difference between other and current; if not, use now.
Use appropriate locale messages.
19. Possibly implement other human-friendly methods like xYearsAgo , or simply rely on
diffForHumans for all such output.
20. Test diffForHumans for past and future dates, and for singular/plural units, in a couple of locales.
21. Milestone:

Carbon.now().subtract(Duration(hours:5)).diffForHumans()

outputs

"5

hours ago" (or equivalent in test locale), matching expected phrases.
22. Time Zone Support with time_machine
23. Add time_machine to pubspec. Write an adapter class (or a variant of Carbon) that uses Time
Machine types. For now, focus on representing a point in time with zone.
24. Implement Carbon.tz(String zone) to convert an instance to given timezone. For Dart
DateTime backend, this can only do UTC or local (with a warning that others require time_machine).
For Time Machine backend, use ZonedDateTime conversion via DateTimeZone.forId(zone) .
25. Ensure Time Machine initialization (e.g., await TimeMachine.initialize() possibly needs to
be called – handle this with an async init function in our library).
26. Test by converting a known UTC time to a known timezone and checking offset. For example, convert
2021-06-01 12:00 UTC to "America/New_York" and expect 08:00 (EDT) etc.
27. Milestone: The library can successfully output the correct local time for at least one non-local
timezone using time_machine data, and formatting with zone info.
28. Macro System & Extensibility
29. Implement Carbon.registerMacro(name, func) and internal structures for storing macros.
Override noSuchMethod in Carbon base class to forward to macro if present. Handle both static
and instance macro if possible (Carbon in PHP allows static macros too 7 32 , we might at least
handle instance).
30. Write tests: register a macro (e.g., daysUntilWeekend ) and verify calling it returns expected result.
Test that unregistered names still throw.
31. Document in code comments how to use extension methods as an alternative.
32. Milestone: A custom macro function can be added in a test and invoked through a Carbon instance to
produce the expected result.
33. Immutable Class Implementation

14

34. Implement CarbonImmutable class. One approach: subclass Carbon but override mutating
methods to return new instances (constructed via a copy of the internal DateTime). Alternatively,
maintain a flag in Carbon and check it; but subclassing is cleaner for type separation.
35. Provide toImmutable() and toMutable() conversion methods. Ensure when converting, the
internal value carries over.
36. Test: original immutable object remains unchanged after calling a mutating method, whereas
mutable does change. Test conversions back and forth.
37. Milestone: Both mutable and immutable variants pass the same test scenarios (except where
mutability should differ). Possibly run all tests with Carbon and again with CarbonImmutable to
ensure parity.
38. Additional Features and Polishing
39. Implement any remaining Carbon-esque features: e.g., startOfWeek/endOfWeek (which might
depend on locale’s first day of week settings), isLeapYear , daysInMonth properties, quarter
of year, etc., to match Carbon’s completeness. These are usually straightforward calculations.
40. Implement any Interval/Period classes if planned (CarbonInterval equivalent using Duration or
Period from time_machine) and CarbonPeriod (for sequences). If not enough time, mark as future
work.
41. Ensure serialization: implement toJson and perhaps support fromJson. Write tests for JSON
encoding a Carbon list, etc.
42. Update documentation in code for all public APIs, prepare a README with usage examples. Possibly
include a comparison table showing Carbon (PHP) method vs our Dart method for users’ reference.
43. Milestone: All planned methods are implemented and documented. All unit tests passing. High test
coverage across different aspects (including using withClock to simulate time).
44. Testing & QA
45. Write comprehensive tests for every feature: creation, parsing, formatting (with multiple locales and
patterns), arithmetic (including cross-boundary cases like end of month wraparound), comparisons,
timezone conversions (especially around DST boundaries), and macros.
46. Test on Dart VM and in a Flutter project (to ensure no platform issues, e.g., time_machine on web).
47. Possibly perform benchmarks to ensure performance is acceptable (especially when using
time_machine, as it might be slower for heavy computations). If needed, optimize critical paths (like
caching formatted strings if repeated, etc.).
48. Get peer review on API design consistency and make adjustments.
49. Milestone: The library achieves a stable 1.0 release state with all tests passing and documented.
50. Release & Future Work
◦ Publish the package on Pub.dev with a version and changelog.
◦ Future enhancements can include: more macro capabilities (static macros), performance
tuning, perhaps integration with cron or scheduling libraries, more period/iteration
utilities, etc.
◦ Encourage community feedback to guide further development.

15

Each milestone above builds on the previous, gradually adding complexity and ensuring a solid foundation.
The highest-risk components (like timezone support and macros) are scheduled mid to later in the project,
once the basics are in place. This allows us to adjust design if needed early without affecting those complex
parts.

Limitations, Trade-offs, and Dart-Specific Constraints
While the plan aims for a comprehensive Carbon clone, there are a few considerations and compromises
due to Dart’s environment:
• Dynamic vs Static: Carbon in PHP relies on dynamic language features (like adding methods at
runtime). Dart’s static type system means our macro system cannot be as transparent. Users might
need to call through a dynamic reference or accept that IDE auto-complete won’t catch dynamically
added methods 20 . This is a trade-off for using a safer, compiled language. We provide the macro
facility, but it’s a bit more verbose to use than in PHP. In practice, many Dart users may prefer using
extension methods for compile-time known extensions, which we fully support as well.
• No Multiple Inheritance: Dart doesn’t allow multiple inheritance, but we leverage mixins to
simulate Carbon’s traits. We must design carefully so that mixins don’t conflict and that the final class
has a consistent interface. The use of mixins in Dart is quite powerful and should suffice for our
needs.
• Time Machine Overhead: Including time_machine (which is large due to time zone data and
complex logic) will increase the package size and possibly memory use. If an application doesn’t
need timezone handling, this is overhead. In trade-off, to be “fully featured” we accept this cost. We
could consider splitting the package (“carbon” core vs “carbon_timezones” addon), but that adds
complexity for the user. We'll note this overhead in documentation and possibly allow stripping
timezone data for tree-shaking if not used.
• Immutability Default: We have to choose whether our primary Carbon class is mutable or
immutable. In this design, we chose to mirror Carbon (PHP) where the default is mutable for
familiarity 21 . However, Dart’s culture (and modern development in general) often favors immutable
data for safety. Developers must be aware of what they use. We provide both options, but this is a
point of divergence from some libraries (e.g., Time Machine’s types are immutable, Moment.js was
mutable, JodaTime in Java was immutable by default). It’s a conscious trade-off to cater to both
preferences.
• Month Arithmetic Edge Cases: Adding months or years can lead to dates that are invalid (e.g., from
Jan 31 + 1 month -> Feb 31 which doesn’t exist). Carbon handles this by shifting to end of month or
allowing overflow control 33 . We will need to define how our library handles this. Likely, we follow
Carbon’s default: overflow goes to next valid date (Feb 28 or Mar 3 depending on overflow settings).
Implementing a monthOverflow setting (like Carbon’s settings(['monthOverflow'
=> ...]) ) might be necessary for full flexibility, but at minimum we should document how we
handle it (probably default to overflow = true, meaning Feb 31 becomes Mar 3 for a non-leap year).
These nuances are inherent to date math.
• Locale Data Requirements: The intl package requires that the relevant locale data is imported
(for example, Flutter typically does this via initializeDateFormatting(locale) function for
each locale). We should ensure our library either documents this or internally calls
initializeDateFormatting for common locales. Otherwise, formatting in other locales might
default to English. We might include instructions or a helper to initialize locales.

16

• Time Zone Database Updates: Time zones change (Daylight rules, etc.), and time_machine
provides a specific TZDB version (e.g., 2022a as noted 34 ). We should update our dependency
periodically to incorporate new TZDB releases. If an app requires an urgent TZ update, they’d have to
update our package or we allow a way to load a custom tz database through time_machine’s API.
• Performance Considerations: Using heavy libraries can slow down operations (e.g., formatting with
intl, or constructing a Time Machine ZonedDateTime ). For most apps, these are fine, but for very
high-frequency computations (like thousands of date ops per frame), this might be a bottleneck. We
trade a bit of performance for correctness and feature richness. We can mitigate some cost by
caching results of expensive operations if repeated (for example, caching last format pattern, but
this might be micro-optimization).
• Consistency Across Backends: We must ensure that using different backends yields the same
results for equivalent operations. For example, adding 1 month via Dart DateTime vs via Time
Machine might differ on edge cases (Time Machine might default to last day of next month if
overflow; Dart DateTime.add(Duration(days:30)) is a crude approximation). To avoid
confusion, our library should either document the slight differences or implement a unified logic at
the Carbon level. Possibly, when using the Dart backend, we manually implement month/year
addition to mimic Time Machine/Carbon logic rather than rely on Duration(days:30) . This
uniformity is important for predictability.
• Testing Complexity: With multiple backends, testing needs to cover each. We will use
parameterized tests or separate test groups for each adapter. We should also test that switching
backend mid-use is either prevented or behaves well. Ideally, a Carbon instance is tied to one
backend forever; mixing operations between two different Carbon types might be problematic (we
should disallow comparing a Carbon(DateTime) with Carbon(TimeMachine) directly, or handle by
converting one to the other’s zone/time).
• Dart Version Constraints: Ensure that our library works with the latest Dart (and Flutter) versions.
Extension methods, if used, require Dart 2.7+, which is fine since we’re targeting 2025 era. Also
ensure it works in both null-safe and possibly older versions if needed (likely require null safety as
default).
• Documentation and Learning Curve: A comprehensive library can be complex. We must provide
clear documentation and examples, as the Carbon PHP docs do. This includes explaining how to use
the various features, and any differences from Carbon PHP (for those familiar with it). We should
highlight the macro usage differences, and how to handle async initialization of time zones, etc., so
developers can quickly get on board.
In summary, while there are some trade-offs due to Dart’s design and the inclusion of heavy features, the
roadmap above mitigates them by using best practices and existing solutions wherever possible. The end
result aims to be a powerful, flexible date/time library that feels natural in Dart and Flutter development,
just as Carbon does in PHP.

Conclusion
By following this roadmap, we will create a fully featured Carbon-style datetime library in Dart that
brings the ergonomic and comprehensive date/time handling of Carbon to Flutter and server-side Dart. The
recommended modular architecture (with a core interface, multiple adapters, and mixin-based feature
grouping) ensures the design is clean, extensible, and maintainable. We integrate proven third-party
packages ( intl , time_machine , timeago , clock ) to accelerate development and focus on gluing
them together under a unified API instead of reimplementing complex logic

17

8

12 . Key design patterns

such as strategy and adapter enable pluggability – developers can choose different underlying
implementations or extend the library with custom behaviors. Our approach to mutability control and
macros provides flexibility similar to Carbon’s (within the realm of what Dart allows) 21 17 .
The project milestones break the work into manageable phases, from core functionality to advanced
features, with testing deeply integrated at each step. By the end, Dart developers will have a library that
simplifies date/time manipulation, supports global applications with time zones and localization, and
improves code readability through a fluent API. This will address the challenges of Dart’s DateTime (and
even existing packages) by offering a cohesive, Carbon-inspired solution.
With careful attention to the outlined tasks, trade-offs, and design principles, this library will become a
robust utility for the community, making date/time handling in Dart intuitive, reliable, and feature-rich,
much like Carbon has done for PHP 1 .
Sources:
• Astar Bekturov, "Intro to Carbon Package: A PHP Extension of DateTime" – highlights Carbon’s ease of
use, timezone support, and extensibility 1 8 .
• Carbon PHP Documentation – details on Carbon vs CarbonImmutable behavior 21 and macro
capabilities 17 7 .
• Dart Time Machine (port of Noda Time) – provides advanced date/time API with timezones and
cultures 13 2 .
• StackOverflow answer by Mohsin Naeem – recommends the timeago package for human-readable
time differences in Dart 12 .
• Iiro Krankka, "Controlling time in Dart unit tests, the better way" – introduces the clock package for
injecting current time in tests

1

3

5

8

9

29

30

4

.

Intro to Carbon Package: A PHP Extension of DateTime | by Astar Bekturov | t14g

| Medium
https://medium.com/t14g/intro-to-carbon-package-a-php-extension-of-datetime-7158a5bc9cf7
2

6

13

14

34

GitHub - Dana-Ferguson/time_machine: A date and time API for Dart

https://github.com/Dana-Ferguson/time_machine
4

Controlling time in Dart unit tests, the better way | iiro.dev

https://iiro.dev/controlling-time-with-package-clock/
7

10

11

15

16

17

18

19

20

21

22

23

24

25

31

32

33

Carbon - A simple PHP API extension for

DateTime.
https://carbon.nesbot.com/docs/
12

Converting DateTime to time ago in Dart/Flutter - Stack Overflow

https://stackoverflow.com/questions/53203376/converting-datetime-to-time-ago-in-dart-flutter
26

27

28

jiffy | Dart package

https://pub.dev/packages/jiffy

18

